# Tutorial basic concept arrays and pointers
## Arrays
### Array Concept
Масссив это последовательность элементов фиксированого размера одного и того же типа.
Идея массива заключается в том чтобы вместо обявления, например 10 переменных, можно обявить массив с 10 элементов доступ к которым возможен через единый индитификатор. Другим словом массив это колекция переменных одного типа.
![](Array.png)

- Массивы нужны когда необходимо хранить большое количество данных 
- Все элементы массива расположенны в памяти последовательно, причем самый нижний адресс массива соответсвует первому элементу, а самый высокий адресс - последнему элементу 
- Элементы массива это самостоятельная единица
- Элементы массива должны быть одного типа
- Каждый элемент массива имеет порядковый номер(индекс)
- Индексация массива начинается с нуля (если размер массива, например 5, то диапазон индексов следующий [0..4])
- Доступ к элементу массива за границей массива есть неопределленное поведение (Undefined Behaviour ISO)
- Все массивы должны быть фиксированого размера (ISO)
- Размер массива всегда должен быть больше нуля(т.е. должен быть не пустой колекцией ISO)
### Work with arrays
#### Array declaration
В этом разделе мы расматриваем только массивы которые выделенные на стеке
```cpp
// тип элементов идентификатор[размер массива];
// примеры
int array[2];
float array1[3];

const size_t count_element = 5;
int array2[count_element];

// const int array3[3]; // не компилируется, т.к. при обьявлении константы в C/C++ ее необходимо инициализировать

/* не компилируется
const float array_size = 10.5;
int array_error[array_size];
*/

// double array4[];
```

- Согласно стандарту размер массива должна быть константная величина целочисленного типа(compile time) и быть больше нуля
- При обьявление массива, если не инициализировать элементы, то содержимое элементов массива является неопределенное значение(содержит муссор)

#### Several ways to declare array size
- Обьявление целочисленной константы
```cpp
const size_t array_size = 5;
int array[array_size];
```
- Использовать директиву препроцессора
```cpp
#define ARRAY_SIZE 10
int array[ARRAY_SIZE];
```

- Использовать перечесление
```cpp
enum {
    ARRAY_SIZE = 5
};

int array[ARRAY_SIZE];
```

#### Initializing arrays
Как было сказано ранее массивы по умолчанию инициализированный неопределенным значение, если инициализирующие значения не указать явно. Инициализирующие значения при обьявление массива могут быть списком инициализации (initializer list), или стровыми литералами (string literal).

```cpp
// примеры
int array[2] = {1, 2}; // теперь массив содержит два элемента со значением 1 и 2
float array1[3] {1.2, 2.5, 3.0}; // массив с тремя вещественными числами со значением 1.2, 2.5, 3.0

int array2[4] {}; // массив с цетырьмя целочисленными значениями, где каждый элемент проинициализирован нулями

int array3[3] {1}; // массив с тремя целочисленными значениями, где первый элемент массива проинициализирован 1, а все остальные нулем

int  array4[] {1,2,3} // в этом случае компилятор сам опредилит размер массива изходя из списка инициализации

// int array[] {} // compiler error

const int array[3] {1,2,3}; // инициализация констатного массива, каждый элемент массива только для чтения
/*
// C initializing style
int a[10] = { 0,1,2, [5]=25,26, [9]=100}; // {0,1,2,0,25,26,0,0,100,0}
*/
```
Инициализировать константные массивы можно только во время обьявление масива
Если размер массива который указан в квадратных скобочках меньше размера элементов в списке инициализации то мы получим ошибку компиляции

```cpp
// int array[3] = {1,2,3,4}; // compile error
```

Стоить заметить что массив не несет в себе информации о своем размере, это стоить помнить при обьявления массива с автоматическим выведением размера. Все это справедливо, кроме массивов типа char.

```cpp
char str1[] = "abc"; // размер этого массива 4 элемента, 3 символа + завершающий ноль \0 ( null character)
char str2[3] = "abc"; // размер этого массива 3 элемента
char str3[4] = "abc"; // размер этого массива 4 элемента, 3 символа + завершающий ноль \0 ( null character)
char str4[20] = "abc"; // размер этого массива 20 элемента, 3 первых символа "abc", остальные элементы инициализируються нулем
char str5[] = { 'a', 'b', 'c' }; // размер этого массива 3 элемента
char str6[] = { 'a', 'b', 'c', '\0' }; // размер этого массива 4 элемента, мы явно указали конец строки
char str7[] = { "abc" }; // размер этого массива 4 элемента, 3 символа + завершающий ноль \0
```

![](Array_declaration.png)

В символьных массивах символ заверщающего нуля '\0' указывает на конец строки. При инициализации символьного массива строковым литералом, и если размер массва указан больше или неуказан явно, компилятор добавляет символ завершающего нуля '\0'. Если мы инициализируем строку списком инициализации символов (str5, str6) компилятор не добавляет специальный символ завершающего нуля.
Символ завершающего нуля очень важен при работе с функциями для работы со строками. Используя строковый литерал можно узнать количество элементов массива.

### Access to array elements
- Доступ к элементу массива осуществляется с помощью индекса
- Индекс это целочисленное значение
- Нумерация начинается с нуля и до размер массива минус 1
- Выход за границы массива это неопределенное поведение(граница имеется ввиду как нижня так и верхняя)
- Элементы константного массива только читать, при попытке что то записать мы получим ошибку компиляции
- Индексом может быть как константное значение, переменная, или выражение
![](Array_access.png)

```cpp
int array[4] = {1,2,3,4}; // обьявляем массив с четырех элементов

// int undefined_value = array[-1]; // доступ к элементу который находиться перед первым элементом массива
// int undefined_last_value = array[4]; // доступ к элементу который находиться после последнего элемента массива [0..3]
int arr_first_elem = array[1]; // считать с памяти значение которое находиться во втором элементе массива
array[2] = 25; // записать значение 25 в третий элемент массива {1,2,25,4}

// int value_array = array[1.35]; // ошибка компиляции, что неверный тип для индекса массива (double) 

int value_array = array[(int)1.35]; // происходит явное преоразование вещественного в целое

const int read_only_array[2] = {1, 2}; // обьявляем константный целочисленный массив

int const_value = read_only_array[1]; // прочитать значение которое находится во втором элементе массива
// read_only_array[1] = 3; // ошибка компиляции, при записи в read only элемент

char index = 1;
int value = read_only_array[index - 1]; // получение первого элемента массива {1}
```
### Arrays and loops
```cpp
int array[3] = {3,4,5};
int summ += array[0];
summ += array[1];
summ += array[2];

// summ == 12
```
Вместо доступа к каждому элементу массива как в примере выше, используют цыклы для обхода массива
- Цыкл for
```cpp
int array[3] = {1,2,3};
// в этом цыкле мы проходимся по массиву array для этого исользуем целочисленный сячетчик i
// в начале цикла мы инициализируем счетчик 0, и после каждой итерации проверяем не вышли ли мы за границу массива, если нет то
// увеличчиваем счетчик на 1
for (size_t i = 0; i < 3; ++i) {
  printf("%d ", array[i]);
}

// с с++11 появился новый вид Range-based for loop
for (auto value: array) {
  printf("%d ", value);
}

```
- Цыкл while
```cpp
int array[3] = {1,2,3};
// в этом цыкле мы проходимся по массиву array для этого исользуем целочисленный сячетчик i
// вначале мы инициализируем счетчик 0, в цыкле мы проверяем не вышли ли мы за границы массива, если нет то печатаем значение
// элемента и увеличиваем счетчик 
size_t i = 0;
while (i < 3) {
  printf("%d ", array[i++]);
}
```

Обход символьного массива возможен немного другой(в случае если символьный массив заканчивается '\0')
```cpp
char str[] = "abcd";
size_t i = 0;
while (str[i]) {
  printf("%c ", str[i++]);
}

for (i = 0; str[i]; ++i) {
  printf("%c ", str[i]);
}

```

Существует следующая проблема с массива: массивы нельзя присваивать друг-другу даже если они одного типа и размера. Стоит заметить что если попробывать присвоить массивы разных размеров или типов, то получим ошибку несовместимости типов
```cpp
int first_array[3] = {1,2,3};
int second_array[3] = {4,5,6};
 
// first_array = second_array; // compilation error

// first_array = {4,5,6}; // compilation error
// first_array = (int [3]){4,5,6}; // compilation error

int value = 10;
// first_array = value; // compilation error, несовместимые типы int и int[3]
first_array[1] = value; // compile ok
```
Циклы используются также и для присвоедние значений одного массива другому
```cpp
#define SIZE_ARRAY(array) sizeof((array)) / sizeof((array)[0]);
int first_array[3] = {1,2,3};
int second_array[3] = {4,5,6};
size_t count_array_first = SIZE_ARRAY(first_array);
size_t count_array_second = SIZE_ARRAY(second_array);

if (count_array_first <= count_array_second) {
  for (size_t i = 0; i < count_array_first; ++i) {
    first_array[i] = second_array[i];
  }
} else {
  printf("Second array size is smaller than size first array");
}

for (size_t i = 0; i < count_array_first; ++i) {
  printf("%d ", first_array[i]);
}

// Массивы  first_array и second_array теперь одинаковы

```
Есть еще другие подходы для присвоение массивов это memcpy со стандартной библиотеки и структуры
```cpp
struct Array
{
  int array[3] = {1,2,3};
};
//.....
  Array ar1;
  ar1.array[0] = 10;
  ar1.array[1] = 20;
  ar1.array[2] = 30;
  Array ar2 = ar1;

  for (auto value: ar2.array) {
    printf("%d ", value); // print 10 20 30
  }
  printf("\n");
```

### Sizeof Array
Размер массива вычесляется как размер в байтах элемента массива умножено на количество элементов
```
sizeof_in_byte_array_element * count_array_element
```
```cpp
int value = 10;
printf("value size is %uz\n", sizeof(value)); // напечатает 4 байта

int array[5] = {2,3,4,5,6};
printf("int array byte size is %uz\n", sizeof(array)); // напечатает 20 байта

double array_double[5] = {2.2, 3.2, 4.5, 5.6, 6.8};
printf("double array byte size is %uz\n", sizeof(array)); // напечатает 40 байта

```
Для того чтобы получить количество элементов массива, необходимо размер массива в байтах разделить на размер элемента в байтах.
```
size_of_all_element_array_in_bytes / sizeof_array_element_in_byte
```

```cpp
int array[5] = {2,3,4,5,6};
printf("int array size is %uz\n", sizeof(array) / sizeof(array[0])); // напечатает 5

```
Вычесление количество элементов массива необходимо, когда компилятор во время инициализации массива выводит сам размер массива
```cpp
int array[] = {2,3,4,5,6}; // компилятор автоматически вывел размер массива 5
size_t count = sizeof(array) / sizeof(array[0]);
for (size_t i = 0; i < count; ++i ) {
  printf("%d ", array[i]);
}
```
### Multidimensional arrays
До этого мы рассматривали одномерные массивы. В С/C++ можно определять многомерные массивы или другими словами массивы массивов.
- Количество уровней ограниченно только памятью
- Многомерные массивы в основном представляют ввиде таблиц(например количество строк * столбцов)
- Размерность уровней многомерного массива может быть разная(но в основном используют квадратные таблицы, или другими словами матрицы)
- Основное применение многомерных массивов это графика(матрицы поворота, переноса и т.д.), или классические алгоритмы(например представление ввиде таблицы лабиринта, или таблица смежности для графа)
- Размерность первого уровня может быть опциональным, а для всех остальных должен быть явно задан
- Все правила для работы с одномерным массиво, также относятся и многомерным массивам(присваивание, доступ и т.д.)
- Доступ к элементу массива происходит с указанием индекса для каждого уровня

![](Array_dimentional.png)

Выше представлен рисунок как вообщем в удобном виде представляют двумерный массив. Но зная что память это линейная величина, то на самом деле в памяти многомерные массивы представлются немного подругом. Т.е. строки представляются в памяти одна за другой. Например первый размер представлен как N, тогда как другой представлен размером M

![](Array_in_memory.png)
Из этого вытекает что любой многомерный массив можно представить одномерным массивом

```cpp
  int array[2][2]; // обьявление двумерного массива(содержит неопределенное значение)
  int array1[3][3] = {1,2,3,4,5,6,7,8,9}; // обьявление и инициализация двумерного массива  
  int array2[3][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; // другой вид инициализации масиива
  // int array1D[3] = array1[1]; //ошибка компиляции инициализация массива возможна только списком инициализации
  int array3D[3][3][3] = {
                          {{1,2,3}, {4,5,6}, {7,8,9}},
                          {{10,11,12}, {13,14,15}, {16,17,18}},
                          {{19,20,21}, {22,23,24}, {25,26,27}}
                         }; // инициализация двумерного массива

  int array2D[][3] = {{1,2,3}, {1,2,3}, {1,2,3}};

  // ошибка компиляции, можно опускать указание размера первого уровня, но не всех остальных
  // int array2D_error[][] = {{1,2,3}, {1,2,3}, {1,2,3}};

  int value = array1[1][1]; // доступ ко второму элементу первого уровня, и второго элемента второго уровня
  printf("Midle element array1 is %d\n", value); // print 5

  value = array3D[0][1][2];
  printf("Midle element array3D is %d\n", value); // print 6

  array2[2][2] = 100;

  printf("======= 2D Array =======\n");
  printf("\tColumn 1 \t Column 2 \t Column 3\n");
  for (size_t i = 0; i < 3; ++i) {
    printf("Row %d\t", i + 1);
    for (size_t j = 0; j < 3; ++j) {
      printf("%5d\t\t", array2[i][j]);
    }
    printf("\n");
  }

  // представление многомерного массива одномерным массивом
  int array1D[3 * 3];
  size_t counter = 0;
  for (size_t i = 0; i < 3; ++i) {
    for(size_t j = 0; j < 3; ++j) {
      array1D[i * 3 + j] = ++counter;
    }
  }
  printf("====2D array via 1D array====\n"); 
  for (size_t i = 0; i < 3; ++i) {
    for(size_t j = 0; j < 3; ++j) {
      printf("%2d\t", array1D[i * 3 + j]);
    }
    printf("\n");
  }
```
```
Output
Midle element array1 is 5
Midle element array3D is 6
======= 2D Array =======
	   Column 1 	 Column 2 	 Column 3
Row 1	    1		    2		    3		
Row 2	    4		    5		    6		
Row 3	    7		    8		  100

====2D array via 1D array====
 1	    2	    3	
 4	    5	    6	
 7	    8	    9
```
### Arrays as Parameters
- Массивы в отличие от примитивных типов не передаются по значению
- Размерность массива при передачи как параметра в функцию игрнорируется
- Определение размера массива как в предедущем разделе с помощью sizeof дает не те ожидаимые результаты
- При передачи как параметра в функцию многомерного массива размерность первого уровня игнорируеться как и для одномерных массивов, а вот размер второго уровня необходимо указывать, иначе будет ошибка компиляции
```cpp
#include <stdio.h>

#define SIZE_ARRAY(array) sizeof((array)) / sizeof((array)[0])

void incorrect_print_array(int array[5]/*the same int array[]*/) {
  // результат будет не такой как ожидается(см. раздел с указателями)
  printf("array size in incorrect function %zu\n", SIZE_ARRAY(array));
  for (size_t i = 0; i < 5; ++i) {
    printf("%d ", array[i]);
  }
  printf("\n");
}

void correct_print_array(int array[], size_t length) {
  for (size_t i = 0; i < length; ++i) {
    printf("%d ", array[i]);
  }
  printf("\n");
}

void buble_sort(int (&array)[5]) {
  for (size_t i = 0; i < 5; ++i) {
    for (size_t j = 0; j < 5 -1; ++j) {
        if (array[j] > array[j + 1]) {
          int tmp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = tmp;
        }
    }
  }
}

// при передачи многомерного массива первый уровень игнорируеться компилятором как при работе с одномерным массивом
// а вот размер второго уровня обьязателен, если его указать или передать неверный размер то будет ошибка компиляции
void print_2D_array(int array[][2], size_t length_first_dim) {
  for (size_t i = 0; i < length_first_dim; ++i) {
    for (size_t j = 0; j < 2; ++j) {
      printf("%5d", array[i][j]);
    }
    printf("\n");
  }
}

int main(void) {
  int array[5] = {5, 4, 3, 2, 1};
  int array2[7] = {7, 6, 5, 4, 3, 2, 1};
  printf("array size is %zu\n", SIZE_ARRAY(array));
  buble_sort(array);
  // buble_sort(array2); compiler error initialization of reference of type ‘int (&)[5]’ from expression of type ‘int [7]’

  incorrect_print_array(array); // print 1 2 3 4 5
  // программа компилируеться без ошибок, так как по умолчанию размер массива игнорируеться
  incorrect_print_array(array2); // print 7 6 5 4 3

  correct_print_array(array2, SIZE_ARRAY(array2)); // print 7 6 5 4 3 2 1

  int array2D[][2] = {{1,2}, {3,4}, {5,6}};
  print_2D_array(array2D, SIZE_ARRAY(array2D));
  // int array2D_error[][3] = {{1,2,3}, {4,5,6}, {7,8,9}};
  // print_2D_array(array2D_error, SIZE_ARRAY(array2D_error)); // compilation error, несовместимость типов(размеров)
  return 0;
}
```

## Memory model
Программе необходимо где то хранить данные с которыми она работает, поэтому выделяют основные виды памяти:
 - Память сегмента кода(загружаються выполняемые инструкции нашей программы)
 - Память сегмента данных(загружаються статические и глобальные переменные), различают еще инициализированную и неинициализированную
 - Стек или другим словом автоматическая память(локальные переменные, аргументы функций, адресс возврата функции)
 - Динамическая память (Куча)
До этого мы работали только с сегментом данных (когда обьявляли глобальные переменные), и стек когда обьявляли локальные переменные вызывали функции. Проблема описанных видов памяти, кроме динамической, в том что их размер предустановлен. Необходимо уточнить что например возможность записать в сегмент кода, тоже не возможен, можно только использовать адресс функций (read-only). Для управления памятью во время выполнения программы, т.е. создание или удаление, используеться только стек и динамическая память.

Идея стека заключается в быстром выделении памяти, т.е. когда наша программа заходит в область видимости, например функции, то необходимо быстро выделить память под переменные. Это достигается одной CPU инструкцией, т.е. мы передвигаем указатель стека(специальный регистр), когда нам необходимо запросить память, и присваиваем переменной адресс на который указывает сейчас указатель стека(указатель стека перемещается с низу вверх). Данные в стеке расположены друг за другом(но необходимо помнить что компилятор делает так называемый memory reordering)
Проблема стека как было сказано выше в том что размер его предустановлен и мы не может контролировать время жизни переменных, т.к. стек это автоматическая мамять. И если нам необходимо больше размер памяти для хранения данных или увеличить время жизни переменных от вызова одной функции к вызову другой, то для этого используется динамическая память.
Но возникает вопрос почему не использовать динамическую памать по умолчанию, как сделано во многих языках программирования, и не будет проблем с переполнением стека и т.д., а ответ на этот вопрос раскрывается в том как память выделяеться в куче. Если программа запрашиввает необходимый обьям памяти, то этот запрос обращается к OS так называемый менеджер памяти, основные обьязательства следующие:
- Проверит есть ли доступная память
- Выделит запрашиваемую память
- И будет держать эту память для вашей программы, чтобы другие процессы не могли получить доступ к вашей памяти
- По вашему запросу освобождает память если она вам больше не нужна(если этого не зделать возникают memory leaks)
- Делает фрагментацию памяти
С выше всего перечесленного можно сделать вывод что выделение памяти это очень дорогая операция. Т.е. разница в производительности между стеком и динамической памятью это как система выделяет память. А вот работа с выделенной паматью ничем практически не отличается от работы с памятью в стеке, только в динамической паматьи образуется один дополнительный уровень косвености(указатель)
### Stack
 - Хранится в RAM как и динамическая память
 - Стек использует так называемую автоматическую работу с памятью (т.е. идея push - pop)
 - Намного производительней в выделении памяти чем динамическая память
 - Хранит локальные данные, адресс возврата функции, передаваемые аргументы функции
 - Т.к. количество памяти на стек ограничено, то возможно переполнения буфера
 - Стек используется если мы знаем точно размер памяти (но в рамках ограничения памяти на стеке)
### Heap
 - Хранится в RAM как и динамическая память
 - Переменные которые выделяются в динамической памяти, должны быть удалены в ручную, т.е. управление динамической памятью происходит вручную
 - Медляней в производительности в выделении памяти, чем стек
 - Память в куче используеться по требованию программы
 - Может возникнуть фрагментация памяти, когда много запросов на выделение и освобожнение
 - Можен возвращать ошибку выделения памяти, если запрос на выделение памяти очень большой чем обьем памяти
 - Возможны memory leaks(утечка памяти), если не освободить выделенную память
 - Куча в основном используеться если мы не знаем какой нам необходим обьем памяти, или время жизни переменой должно быть больше чем область например функции 
## Pointers
### Pointers Concept
Укзатель это не что иное как целочисленная переменная которая хранит адресс памяти где находится значение. Т.е. указатель всегда является целочисленной переменой (number), на разных платформах размер может быть разным, например на 32 битной OS это 4 байта, на 64 битной OS это почти всегда 8 байт. Часто очень путают когда говорят что указатель на int или float, это не совсем верно, тип для указателя это нечто информативное программе сказать сколько байт положить в ячейку памяти расположенном по этому адрессу. 
Указатели можно сравнить в жизненой ситуации, когда например мы знаем номер дома, и мы идем по этому адрессу чтобы например встретится с друзьями или забрать посылку.
Все переменные имеют адресс, для нас в программе это индитификаторы, а для компилятора это адресс по которому надо записать или прочитать значение. Указатель это тоже переменная которая иммет адресс.
Указатель очень важная сущность для управление памятью. Все что происходит в нашей программе это работа с памятью, когда наша программа выполняется она загружается в память, все инструкции расположенны в памяти и т.д.
Часто думаю что указатель тесно связан только с динамической памятью, но это не совсем так. Давайте рассмотрим частые случаии использования указателя:
- Указатель может содержать адресс ячейки памяти в стеке
- Указатель может содержать адресс ячейки памяти в куче
- Указатель может содержать адресс функции
Указатель это косвенная опреация, т.е. необходимо обратится к адрессу для того чтобы прочитать или записать в память, в отличии от обычных переменных где запись или чтение происходит непосредственно по адрессу
Стандарт языка C не оговаривает форму представления адресов памяти. Это очень важное замечание, поскольку разные архитектуры могут использовать разные модели адресации. 
### Work with pointers
#### Pointers declaration
```cpp
// Указатель обьявляеться как обычная переменная только с добавление звездочки между типом и переменной
// тип * имя_указателя;
int *ptr; // обявляеться переменная которая хранит адресс по которому можно читать или писать 4 байта
```
Как было замечено ранее, тип необходим только компилятору что помнимать сколько в ячейку писать байт и сколько считывать. В правильно понимании указатель обьявляется как нетипизированный
```cpp
void *ptr; // т.е. обьявляется не типизированный указатель
```
Проблема в том чтобы например нам записать что то по этому адрессу или прочитать, нам необходимо преобразовать к конкретному типу.
Стоит отметить что опреция звездочка относиться только первому индетификатору, если обьявлять переменные через запятую

```cpp
// int *ptr, ptr1, ptr2; // т.е. обьявляется указатель ptr, и две целочисленные переменные ptr1 и ptr2
int *ptr, *ptr1, *ptr2; // т.е. обьявляется указатель ptr, и две целочисленные переменные ptr1 и ptr2
// Если мы бы обьявляли указатель как не типизированный, то мы бы получили ошибку компиляции, т.к. нет такого типа void
```
При обявлении указателя, так же как и при обьявлении обычной переменной, этот указатель содержит муссор. И при попытке обратися по этому значению, мы в лучшшм случае получим segmantation fault, т.е попытка обратится к не существующей памяти. По стандарту обращение к неициализированому указателю это UB.
Поэтому указатель при обьявлении инициализируют валидным адрессом или специальным значение null, т.е указатель никуда не указывает. В C++ есть три вида инициализации указателя нулем: 
- макросом NULL
- целочисленным нулем
- специальным значение для указателя nullptr(C++11)
```cpp
int *ptr = NULL;
int *ptr1 = 0;
int *ptr2 = nullptr; // такая инициализация возможна только начиная с C++11
```
Для инициализации указателя адрессом используется символ &. Основной опрерацией для указателя является получение или запись значение которое расположенно по адрессу хранящемся в указателе. Это делается с помощью символа *(да так же само как и при обьявлении указателя), т.е. словами это можно выразить дай или запиши значение которое хранится по этому адрессу. Если у нас непроинициализированный указатель или проинициализирован null то мыполучим или segmantation fault или UB. Поэтому перед разыменования указателя его проверяю на nullptr
```cpp
#include <iostream>

int main(void) {
  int value = 10;
  int *ptr;
  // покажем что каждая переменная имеет свой адресс
  std::cout << "Address value is" << &value << " address ptr is " <<  &ptr << "\n";
  std::cout << "Address where is ptr poineters " <<  ptr << "\n"; // сдесь мы получим муссор
  ptr = 0;
  std::cout << "Address where is ptr poineters " <<  ptr << "\n"; // теперь получим ноль
  ptr = &value; // присвоим указателю адресс пременной
  std::cout << "Address where is ptr poineters " <<  ptr << "\n"; // теперь указатель содержит адресс переменной value
  std::cout << "Address value is " << &value << " address ptr is " <<  &ptr << "\n"; // но адресса переменных все также разнные  
  std::cout << "Value is " << value << " Poinert to address " << ptr << " has the next value " << *ptr << "\n";
  *ptr = 55; // меняе значение которое расположено в переменной value
  // value тоже изменилось
  std::cout << "Value is " << value << " Poinert to address " << ptr << " has the next value " << *ptr << "\n";

  // Работа с не типизированным указателем
  void *ptr_void = nullptr;
  int int_value = 20;

  ptr_void = &int_value;
  std::cout << "Address value is " << &int_value << " address where is pointers " <<  ptr_void << "\n";
  // получим ошибку компиляции т.к. нетипизированный указатель необходимо приводит к типу при получении данных
  // std::cout << "Value " << int_value << " Pointers value " <<  *ptr_void << "\n";
  std::cout << "Value " << int_value << " Pointers value " <<  *((int *)ptr_void) << "\n"; // compile ok, явное приведение типов
  double double_value = 10.4;
  ptr_void = &double_value;
  std::cout << "Address value is " << &double_value << " address where is pointers " <<  ptr_void << "\n";
  std::cout << "Value " << int_value << " Pointers value " <<  *((double *)ptr_void) << "\n"; // compile ok, явное приведение типов
  return 0;
}
```
#### Pointers and function parameters
Одной из важных применений указателей является использование указателей как аргумента функции. По умолчанию параметры передаються в функцию по значению, т.е. копируються, и изменение которые выполняються над переменной в функции никак не отражаються нажд оригинальной переменной. Для того чтобы было возможность изменять аргумент передаваемый в функцию, используют следующие виды передаачи параметров:
- По ссылке
- По указателю
При передаче по указателю происходит копирование адресса, но внутри функции при разыменования указателя происходит обращание к оригинальному значению. Но при работе с укзателями всегда перед разыменовании необходимо проверять указатель на нуль. Разница в при передачи параметра по ссылке и по указателю, в том что ссылку не нужно проверять на ноль.
При возврата адресса локальной переменной с функции, ввиде указателя являеться неопределенным поведением.
В Google code style для C++ есть правило что изменяемые параметры в функцию должны передаватся по указателю
```cpp
#include <stdio.h>

void copy_swap_func(int a, int b) {
  int tmp = a;
  a = b;
  b = tmp;
}

void swap_func(int *a, int *b) {
  if (a != nullptr && b != nullptr) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
  } else {
    printf("One of the argument is null\n");
  }
}

int main(void) {
  int first_value = 10;
  int second_value = 20;
  printf("Before swaping first value is %d second value is %d \n", first_value, second_value);
  copy_swap_func(first_value, second_value); // ничего не измениться т.к. внутри функции происходим обмен данными для копий
  printf("After swaping first value is %d second value is %d \n", first_value, second_value);
  swap_func(&first_value, &second_value);
  printf("After ptr swaping first value is %d second value is %d \n", first_value, second_value);
  swap_func(&first_value, nullptr); // напечатаеться сообщение что один из аргументов null
  return 0;
}
```
```
Output
Before swaping first value is 10 second value is 20 
After swaping first value is 10 second value is 20 
After ptr swaping first value is 20 second value is 10 
One of the argument is null
```
#### Const Pointers and pointers to const
Выше мы расматривали указатели которым можно было менять адресс. В C++ есть такой тип указателя как константный, т.е. указатель адресс которого нельзя менять, адресс указывается при обьявлении указателя. Другой тип указателя это указатель который указывает на константное значение, т.е. сам адресс указателя может меняться, а вот значение по этому адрессу можно только читать но не изменять. Также можно обьявлять константный указатель на константные данные, т.е. значение на которое указывает указатель нельзя изменять и сам указатель нельзя менять.
```cpp
#include <iostream>

int main(void) {
  int value = 10;
  int *ptr;
  // покажем что каждая переменная имеет свой адресс
  std::cout << "Address value is" << &value << " address ptr is " <<  &ptr << "\n";
  std::cout << "Address where is ptr poineters " <<  ptr << "\n"; // сдесь мы получим муссор
  ptr = 0;
  std::cout << "Address where is ptr poineters " <<  ptr << "\n"; // теперь получим ноль
  ptr = &value; // присвоим указателю адресс пременной
  std::cout << "Address where is ptr poineters " <<  ptr << "\n"; // теперь указатель содержит адресс переменной value
  std::cout << "Address value is " << &value << " address ptr is " <<  &ptr << "\n"; // но адресса переменных все также разнные  
  std::cout << "Value is " << value << " Poinert to address " << ptr << " has the next value " << *ptr << "\n";
  *ptr = 55; // меняе значение которое расположено в переменной value
  // value тоже изменилось
  std::cout << "Value is " << value << " Poinert to address " << ptr << " has the next value " << *ptr << "\n";

  // Работа с не типизированным указателем
  void *ptr_void = nullptr;
  int int_value = 20;

  ptr_void = &int_value;
  std::cout << "Address value is " << &int_value << " address where is pointers " <<  ptr_void << "\n";
  // получим ошибку компиляции т.к. нетипизированный указатель необходимо приводит к типу при получении данных
  // std::cout << "Value " << int_value << " Pointers value " <<  *ptr_void << "\n";
  std::cout << "Value " << int_value << " Pointers value " <<  *((int *)ptr_void) << "\n"; // compile ok, явное приведение типов
  double double_value = 10.4;
  ptr_void = &double_value;
  std::cout << "Address value is " << &double_value << " address where is pointers " <<  ptr_void << "\n";
  std::cout << "Value " << int_value << " Pointers value " <<  *((double *)ptr_void) << "\n"; // compile ok, явное приведение типов
  return 0;
}
```
```
Output
Value is 20 value where pointers cptr 20
Value is 40 value where pointers cptr 40
Value is 25 value where pointers cptr1 25
Value is 40 value where pointers cptr1 40
Value is 2 value where pointers cptr3 2
```
#### Work with dynamic memory
До этого мы использовали указатели которые хранили адресс переменной выделенной на стеке. В отличие от работы со стеком, работа с динамической паамятью возможна только через стек. Т.е. программа с помощью системной функции запрашивает блок памяти в OS, и OS возращает указатель содержащий адресс начала выделенной памяти или нулевой указатель в случае если OS не может выделить запрашиваемый кусок памяти.
Ипользуют два вида выделении памяти в C++
- используют системную функцию malloc или calloc
- или опрератор new и new[] для массивов
Для освобождения памяти используют следующие фунции и операторы
- free
- new и new[] - для массивов
Стоит заметить что при попытке повторной освобождении памяти или удаления нулевого указателя программа может закрешится 
Если динамическая память выделяеться спомощью системной функции malloc или calloc, то освобождаться должна только free. Если память выделялась спомощью опреатора new или new[], то должна освобождатся с помощью delete и delete[].
Для того чтобы выделить память под массив спомощью системных функций malloc и calloc используется следующее правило (кол * размер_типа_в_байтах), но в C++ пользуется соответсвенно оператором new[] и delete[]. При чем например если выделить память с помощью оператора new[] а освободить с помощью delete, то произойдет утечка памяти.
Если динамическая память была выделена спомощью выше описанных функций, и не осбождена, то произойдет утечка памяти. Освобождение памяти произойдет только после того как программа завершиться.
```cpp
#include <stdio.h>
#include <stdlib.h>

int* allocate_memory() {
  int *memory = new int(100);
  return memory;
}

int main(void) {
  // в C++ необходимо явно преобразовывать возращаемый тип в функции malloc, т.к. функция возвращает нетипизированный указатель
  int *ptr = (int *)malloc(sizeof(int));
  printf("Value in ptr is %d \n", *ptr); // содержит муссор
  *ptr = 54;
  printf("Value in ptr is %d \n", *ptr); // print 54
  free(ptr);
  // free(ptr); // our program is crash double free
  ptr = nullptr;
  // free(ptr); // our program crash, ptr is null
  ptr = (int *)calloc(1, sizeof(int));
  printf("Value in ptr is %d \n", *ptr); // согласно документации calloc - the memory is set to zero.
  free(ptr);

  // C++ allocate memory style
  ptr = new int(20); // в отличии от системных функций в операторе new можно указывать инициализирующее значение 
  printf("Value in ptr is %d \n", *ptr); // print 20
  delete ptr; 

  const int count_memory = 5;
  // Allocate memory for array
  ptr = (int *)malloc(count_memory * sizeof(int)); // or calloc(count_memory, sizeof(int))
  free(ptr);

  ptr = new int [count_memory] {1,2,3,4}; // значения можно инициализировать также как массивы
  // delete ptr; // memory leaks
  delete[] ptr;
  
  auto ptr1 = allocate_memory();
  printf("Value in ptr1 is %d \n", *ptr1); // print 100
  delete ptr1;
  return 0;
}
```
#### Pointer Operations
Кроме рассмотреной выше опрации разыменования указателя, также к указателям применимы следующие опреции
- != сравнивают на неравенство двух указателей (часто используют при сравнении с nullptr)
- == сравниваю на равенство два указателя(часто использется при сравнении адрессов в массиве)
- >=, <=, сравнение указателей, например имеет место при сравнении в стеке адресов, при барьерных решениях
Самая часто применимая операция это !=.
```cpp
#include<iostream>
#include <stdlib.h>

void stack_seq_check() {
  int a = 10;
  int b = 20;

  int *ptr1 = &a;
  int *ptr2 = &b;
  std::cout << "ptr1 address " << ptr1 << " ptr2 address " << ptr2 << "\n";
  if (ptr1 < ptr2) { // может быть тоже неопределенным поведением (compiler reordining)
    std::cout << "ptr1 > ptr2 \n";
  }
}

void check_on_null(int *a, int *b) {
  if (a == nullptr || b == nullptr) {
    std::cout << "a or b is null \n";
    return;
  }
  if (a != b) {
    std::cout << "a and b is diferent \n";
  } else if (a == b) {
    std::cout << "a and b is the same \n";
  }
}

int main(void) {
  int *ptr = (int *)malloc(sizeof(int));
  int *ptr1 = (int *)malloc(sizeof(int));
  std::cout << "ptr address " << ptr << " ptr1 address " << ptr1 << "\n";
  if (ptr < ptr1) { // неопределенное поведение
    std::cout << "ptr < ptr1 \n" ;
  }
  stack_seq_check();
  int a = 20;
  int b = 30;
  check_on_null(&a, &b); // print a and b is different
  check_on_null(&a, &a); // print a and b is the same
  return 0;
}
```
#### Pointer Arithmetic
Следующий набор арифметических операций может применяться с указателями
- инкремент ++
- декримент --
- опрецации сложения (+, +=)
- опрецации вычитания (-, -=)
- разница между указателями
```cpp
// сложение и вычитание имеет следующую формулу
// количество*sizeof(тип)
int *ptr;
.....
++ptr; // это не значит что мы увеличили указатель на 1, это означает что мы переместили указатель на 4(int) байта вперед
--ptr; // переместили на 4 байта назад
ptr += 4; // переместили указатель 16 байт вперед
```
Адрессная арифметика очень важна при работе с массивами. Типом адрессной арифметики является тип ptrdiff_t, в этот тип может безопасно быть помещен любой указатель за исключением указателя на функцию.
Разыменование указателя, после адрессной арифметики, которая может призвести до выхода за границы выделеной памяти, являеться не определенным поведением.
Любая арифметика может применяться к нетипизированным указателям
```cpp
#include <iostream>
#include <stdlib.h>

// Печать содержимого динамического массива, используя указатель на начало массива
// и указатель на элемент следующий за последним элементом массива
void print(int *begin, int *end) {
  if (begin != nullptr && end != nullptr && begin != end) {
    while (begin != end) {
      std::cout << " Value = " << *(begin++);
    }
    std::cout << "\n";
  }
}

void stack_arithmetic() {
  int a = 10;
  int b = 20;
  std::cout << " a = " << a << " b = " << b << "\n";

  int *ptr = &a;
  // if compile project with optimization flag (-O2) this behaviour is undefined
  // but if compiled without optimization flag probably print 10 and 20
  std::cout << " ptr to a = " << *ptr << " ptr to b = " << *(++ptr) << "\n";
}
int main(void) {
  int *ptr_array = (int *)malloc(6 * sizeof(int));
  int *begin = ptr_array;
  int *end = ptr_array + 6l;
  char counter = 0;
  while (begin != end) {
    *(begin++) = ++counter; 
  }
  print((begin = ptr_array), end);

  void *void_ptr = ptr_array;
  //++void_ptr; // любая адрессная арифиметика для нетипизированого указателя запрещена
  free(void_ptr);

  int *ptr_value = (int *)malloc(sizeof(int));
  *ptr_value = 20;
  std::cout << "Int ptr value is " << *ptr_value << "\n";
  // ++ptr_value; // является неопределенным элементом, т.к. выход за границы выделенной памяти
  stack_arithmetic();
  return 0;
}
```
#### Array and pointers
Что может быть общего между указателями и массивами? Имя массива это фактически указатель на первый элемент массива, фактический всмысле содержит адресс первого элемента. Иногда говорят что имя массива это константный указатель на первый элемент, но я бы сказал что это детали реализации, т.е. это все неявно. Поэтому становиться понятно почему массивы нельзя друг другу присваивать как обычные переменные(но как элементы структуры можно). Ясно одно, и что точно можна сказать что имя массива неявно ковертируеться в укзатель.
Когда мы видим следующую инструкцию
```cpp
array[1] = 1;
```
эта интсрукция на самом деле преобразуется в следующую инструкцию
```cpp
*(array + 1) = 1;
```
Кстати оператор квадратные скобочки также применим и динамическим указателям
Когда мы создавали функцию, которая принимает в качестве параметра мессив
```cpp
void func(int array[5]/*то же что и int array[]*/)
```
И у нас эта функция принимала абсолютно все одномерные массивы разных размеров, а это все и за того что на саммом деле эта функция выглядит следующим образом
```cpp
void func(int *array)
```
И теперь становиться понятно почему размер массива внутри функции вычеслялся не правильно. Размер массива это sizeof его элементов умножено на количество элементов, тогда как размер указателя это 8 или 4 или 2 байта в зависимости от платформы
Массив содержит следующую информацию
- адресс первого элемента массива (наверное сonst pointer)
- тип элементов массива
- и длина массива
Тогда как указатель содержит следующую информацию
- адресс элемента на который указатель указывает
- тип элемента на который он ссылается
Указатель это массив длиной в один элемент

#### Pointers to functions
Указатель как было сказано выше может ссылкатся на функцию. Часто указатели на функцию используются для так называемых callback или в потоках и т.д.
```cpp
#include <stdio.h>

int print_value(int value) {
  printf("Callback Value is = %d\n", value);
  return value + 1;
}

// обьявляем тип указатель на функцию
typedef int (*FuncCallback)(int value);

int main(void) {
  // обьявляем массив указателей на функции
  FuncCallback func_callback[] = {print_value, print_value};
  int value = 1;
  for (auto callback : func_callback) {
    value = callback(value);
  }
  return 0;
}
```
#### Array of pointers
Можно также обьявлять массив указателей. В примере с предыдущего раздела мы уже обьявляли массив указателей на функции. Зачем вообще может понадобиться массив указателей, например когда в в двухмерном массиве размер творого уровня может меняться, т.е. каждый элемент массива может быть массивом от одного элемента до N. Но в таком ввиде массивы очень сложно поддерживать т.к. необходимо помнить границу для каждого эдлемента массива. Другой пример это когда массив содержит более сложные обьекты, например структуры.
Стоит отметить то если для элемента массива который является указателем, была выделенна память, то эту память необходимо освободить.
```cpp
#include <stdio.h>
#include <stdlib.h>

size_t const array_size = 5;

// необходимо передавать двойной указатель т.к. в функции выделяеться память для
// каждого элемента массива, т.е. необходимо перезаписать адресс 
void allocate_memory(int **memory) {
  *memory = (int *)malloc(array_size * sizeof(int));
  for (size_t i = 0; i < array_size; ++i) {
    (*memory)[i] = i + 1;
  }
}

int main(void) {
  int *array[array_size] = {0};
  for (auto &ptr : array)
    allocate_memory(&ptr);

  for (size_t i = 0; i < array_size; ++i) {
    for (size_t j = 0; j < array_size; ++j) {
      printf("Array [%zu][%zu] = %d\n", i, j, array[i][j]);
    }
  }
  // надо не забывать освобождать выделенную память,
  // т.к. буде утечка памяти
  for (auto &ptr: array) {
    if (ptr != nullptr) {
      free(ptr);
    }
  }
  return 0;
}
```